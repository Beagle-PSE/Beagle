#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass sdqthesis
\use_default_options true
\master ../Requirements Specification.lyx
\maintain_unincluded_children false
\language british
\language_package babel
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Purpose and Goals
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This part is a general introduction for the reader.
 It is written in continuous text.
\end_layout

\begin_layout Plain Layout
The reader should be introduced in the general conditions that make this
 software useful.
\end_layout

\begin_layout Plain Layout
It should explain the starting point (i.e.
 analysis of component-based software & reverse engineering of the model
 from source code), the shortcomings and challenge (i.e.
 no resource demand annotations), and how our software will try to solve
 that.
\end_layout

\begin_layout Plain Layout
It can be regarded as the document’s abstract.
 Therefore, it should give the reader an overview about what this software
 is going to do, such that he will have no surprises when reading the following
 chapters.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When developing software, specifying its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glslink{software architecture}{architecture}
\end_layout

\end_inset

 in a sophisticated way is a crucial, yet challenging task.
 Decisions made at this point often highly influence software's properties,
 such as maintainability and performance
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite these statements
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{Palladio}
\end_layout

\end_inset

 is a software enabling developers to analyse performance and other such
 metrics of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{component-based software}
\end_layout

\end_inset

 at the definition phase, before actually writing any code.
 To achieve that, the software is meta-modelled by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If no code exists yet, models are created completely manually.
 But in many scenarios some to all source code has already been written.
 In such cases however, analysis with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{Palladio}
\end_layout

\end_inset

 might still be wished.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{SoMoX}
\end_layout

\end_inset

 is a tool for static code analysis of source code, to re-engineer the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glsuseriii{software architecture}
\end_layout

\end_inset

 into a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

.
 Unfortunately, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glsuseri{SoMoX}
\end_layout

\end_inset

 results are limited, as they do not contain 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{resource demand}
\end_layout

\end_inset

 which are essential for performance analysis.
\end_layout

\begin_layout Standard
The purpose of this project is to analyse software dynamically by conducting
 performance measurements on its source code, in order to determine the
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{resource demand}
\end_layout

\end_inset

 of its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glsuseri{component}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{internal action}
\end_layout

\end_inset

.
 Adding this information to the software's 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

 will enable developers to use 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{Palladio}
\end_layout

\end_inset

 to analyse and optimise their existing software with minimal effort.
\end_layout

\begin_layout Section
Must Have Criteria
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Specifies criteria our software must fulfil to be considered a success.
\end_layout

\begin_layout Plain Layout
Keep in mind to only specify the 
\emph on
minimum
\emph default
 amount of requirements to make the software useful.
 That means that any criterion not 
\emph on
required
\emph default
 to give the software a right to exist should go into the nice to have part.
\end_layout

\begin_layout Plain Layout
But be nonetheless precise and leave nothing out.
 
\end_layout

\begin_layout Plain Layout
Make sure to differentiate these criteria and the requirements! The criteria
 listed here a bullet points for features and are most of the time not measurabl
e (but surely verifiable!).
 They are what a non-IT client would specify.
 Requirements, on the other hand, are quantified, measurable atomic feature
 descriptions.
\end_layout

\begin_layout Plain Layout
Reference notation is /C#/
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/C10/"

\end_inset

 Beagle shall enable the user to analyse given source code for its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glsuserii{internal action}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{resource demand}
\end_layout

\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/C20/"

\end_inset

 Beagle shall automatically annotate its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{resource demand}
\end_layout

\end_inset

 findings in a given instance of the software 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Nice to Have Criteria
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Complements the above part.
 Criteria listed here don’t need to be matched for the software to be successful.
\end_layout

\begin_layout Plain Layout
This part should be visionary and state as many features that would add
 additional value to the software.
 It should also prove that we made up our minds about our software and can
 exactly imagine its usefulness.
 Criteria specified here may also be implemented by others, long after we’ve
 finished our project.
\end_layout

\begin_layout Plain Layout
Reference notation is /OC#/
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/OC10/"

\end_inset

 Beagle should determine the approximate probability in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{branch}
\end_layout

\end_inset

, which are annotated in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

, for each case.
 If the probability depends on the input parameters, Beagle should determine
 this dependency.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/OC20/"

\end_inset

 The branch probability as a function of the input parameters should be
 annotated in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/OC30/"

\end_inset

 Beagle should determine in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{loop construct}
\end_layout

\end_inset

, which are annotated in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

, too, how often the loop body is executed aproximalty.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/OC40/"

\end_inset

 The number of loop executions as a function of the input parameters should
 be annotated in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{PCM}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Boundary
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This part concludes this chapter’s thought of train.
\end_layout

\begin_layout Plain Layout
Having specified what our software must and should do, we now specify what
 will never be its purpose.
 Any good definition does not only include, but also exclude features.
 This chapter does further prove that we exactly understand what our software
 is – and what it’s not.
\end_layout

\begin_layout Plain Layout
Reference notation is /B#/
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/B10/"

\end_inset

 Beagle does not perform actual measurements on source code.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/B20/"

\end_inset

 Beagle does not reconstruct a model of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glsuseriv{software architecture}
\end_layout

\end_inset

 from their source code.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/B30/"

\end_inset

 Beagle does not reconstruct the internal structure of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
glspl{component}
\end_layout

\end_inset

 like their 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
gls{SEFF}
\end_layout

\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/B40/"

\end_inset

 Beagle only analyses Java programs.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset CommandInset label
LatexCommand label
name "/B50/"

\end_inset

 Beagle does no performance analysis or prediction.
\end_layout

\end_body
\end_document
