<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MeasurementResultAnalyserAverage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Averaging Measurement Result Analyser</a> &gt; <a href="index.source.html" class="el_package">de.uka.ipd.sdq.beagle.analysis.averaging</a> &gt; <span class="el_source">MeasurementResultAnalyserAverage.java</span></div><h1>MeasurementResultAnalyserAverage.java</h1><pre class="source lang-java linenums">package de.uka.ipd.sdq.beagle.analysis.averaging;

import de.uka.ipd.sdq.beagle.core.Blackboard;
import de.uka.ipd.sdq.beagle.core.BlackboardStorer;
import de.uka.ipd.sdq.beagle.core.ExternalCallParameter;
import de.uka.ipd.sdq.beagle.core.MeasurableSeffElement;
import de.uka.ipd.sdq.beagle.core.ResourceDemandingInternalAction;
import de.uka.ipd.sdq.beagle.core.SeffBranch;
import de.uka.ipd.sdq.beagle.core.SeffLoop;
import de.uka.ipd.sdq.beagle.core.analysis.MeasurementResultAnalyser;
import de.uka.ipd.sdq.beagle.core.analysis.MeasurementResultAnalyserBlackboardView;
import de.uka.ipd.sdq.beagle.core.analysis.ReadOnlyMeasurementResultAnalyserBlackboardView;
import de.uka.ipd.sdq.beagle.core.evaluableexpressions.ConstantExpression;
import de.uka.ipd.sdq.beagle.core.evaluableexpressions.EvaluableExpression;
import de.uka.ipd.sdq.beagle.core.measurement.LoopRepetitionCountMeasurementResult;
import de.uka.ipd.sdq.beagle.core.measurement.ResourceDemandMeasurementResult;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * This implementation of {@link MeasurementResultAnalyser} will contribute with static
 * created ProposedExpressions. It will take all SeffElements and use respectively all
 * their MeasurementResults on the {@link Blackboard} and calculate thereby an expression
 * that fits best to the average expectancy value. Its implementation of
 * {@link #canContribute(ReadOnlyMeasurementResultAnalyserBlackboardView)} checks if there
 * are any MeasurementResults for a SeffElement, that have not been flown into the average
 * proposed Expression so far.
 *
 *
 * @author Ansgar Spiegler
 */
<span class="fc" id="L34">public class MeasurementResultAnalyserAverage</span>
	implements MeasurementResultAnalyser, BlackboardStorer&lt;HashMap&lt;MeasurableSeffElement, Integer&gt;&gt; {

	@Override
	public boolean canContribute(final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard) {

<span class="fc" id="L40">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="fc" id="L41">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="fc bfc" id="L43" title="All 2 branches covered.">		if (measurableSeffContributions == null) {</span>
<span class="fc" id="L44">			return this.firstDemandCanContribute(blackboard);</span>
		}

<span class="fc bfc" id="L47" title="All 2 branches covered.">		if (measurableSeffContributions.isEmpty()) {</span>
<span class="fc" id="L48">			return false;</span>
		}

<span class="fc bfc" id="L51" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : measurableSeffContributions.keySet()) {</span>

<span class="fc" id="L53">			final Integer numberOfMeasurements =</span>
<span class="fc" id="L54">				this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement);</span>

<span class="fc bfc" id="L56" title="All 2 branches covered.">			if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="fc" id="L57">				return true;</span>
			}
<span class="fc" id="L59">		}</span>

<span class="fc" id="L61">		return false;</span>
	}

	@Override
	public void contribute(final MeasurementResultAnalyserBlackboardView blackboard) {

<span class="fc" id="L67">		final HashMap&lt;MeasurableSeffElement, Integer&gt; writtenContent =</span>
<span class="fc" id="L68">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="fc bfc" id="L70" title="All 2 branches covered.">		if (writtenContent == null) {</span>
<span class="fc" id="L71">			final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions = this.initializeMap(blackboard);</span>
<span class="fc" id="L72">			blackboard.writeFor(MeasurementResultAnalyserAverage.class, measurableSeffContributions);</span>
		}

<span class="fc" id="L75">		this.scanAllMeasurableSeffElements(blackboard);</span>

<span class="fc" id="L77">	}</span>

	/**
	 * Called if this class has no written content on the Blackboard yet. Checking if
	 * there are any MeasurementResults for any SeffElement.
	 *
	 * @param blackboard the blackboard to read from
	 * @return {@code true} if the blackboard contains MeasurementResults, otherwise
	 *         {@code false}
	 */
	private boolean firstDemandCanContribute(final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard) {

<span class="fc" id="L89">		final Set&lt;MeasurableSeffElement&gt; allMeasurableSeffElementsOnBlackboard = new HashSet&lt;MeasurableSeffElement&gt;();</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllRdias()) {</span>
<span class="fc" id="L92">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L93">		}</span>

<span class="fc bfc" id="L95" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffBranches()) {</span>
<span class="fc" id="L96">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L97">		}</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffLoops()) {</span>
<span class="fc" id="L100">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L101">		}</span>

<span class="fc bfc" id="L103" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllExternalCallParameters()) {</span>
<span class="fc" id="L104">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L105">		}</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : allMeasurableSeffElementsOnBlackboard) {</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">			if (this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement) &gt; 0) {</span>
<span class="fc" id="L109">				return true;</span>
			}
<span class="nc" id="L111">		}</span>

<span class="fc" id="L113">		return false;</span>

	}

	/**
	 * Scanning all {@link MeasurableSeffElement} for given MeasurementResults. If there
	 * are more results than the number of results for a previous propose have been used,
	 * a new ProposedExpression is added by
	 * {@link #addMeasurementResultFor(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 *
	 * @param blackboard the {@link Blackboard} to read and write from
	 */
	private void scanAllMeasurableSeffElements(final MeasurementResultAnalyserBlackboardView blackboard) {

<span class="fc" id="L127">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="fc" id="L128">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : measurableSeffContributions.keySet()) {</span>

			final Integer numberOfMeasurements;

<span class="fc bfc" id="L134" title="All 2 branches covered.">			if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="fc" id="L135">				numberOfMeasurements =</span>
<span class="fc" id="L136">					blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="fc" id="L138">					this.addMeasurementResultFor(blackboard, (ResourceDemandingInternalAction) measurableSeffElement);</span>
				}
<span class="fc bfc" id="L140" title="All 2 branches covered.">			} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="fc" id="L141">				numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="fc" id="L143">					this.addMeasurementResultFor(blackboard, (SeffBranch) measurableSeffElement);</span>
				}
<span class="fc bfc" id="L145" title="All 2 branches covered.">			} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="fc" id="L146">				numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="fc" id="L148">					this.addMeasurementResultFor(blackboard, (SeffLoop) measurableSeffElement);</span>
				}
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">			} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="fc" id="L151">				numberOfMeasurements =</span>
<span class="fc" id="L152">					blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="fc" id="L154">					this.addMeasurementResultFor(blackboard, (ExternalCallParameter) measurableSeffElement);</span>
				}
			}

<span class="fc" id="L158">		}</span>

<span class="fc" id="L160">	}</span>

	/**
	 * This method creates an averaging {@link EvaluableExpression} over all given
	 * measurement results for this {@link MeasurableSeffElement} and adds it to the given
	 * {@link Blackboard}. At the end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param rdia MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final ResourceDemandingInternalAction rdia) {

<span class="fc" id="L177">		final Set&lt;ResourceDemandMeasurementResult&gt; measurementResults = blackboard.getMeasurementResultsFor(rdia);</span>
<span class="fc" id="L178">		int sumOverAllMeasurementResultValues = 0;</span>
<span class="fc" id="L179">		final int numberOfAllMeasurementResults = measurementResults.size();</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">		for (final ResourceDemandMeasurementResult rdmr : measurementResults) {</span>
<span class="fc" id="L182">			sumOverAllMeasurementResultValues += rdmr.getValue();</span>
<span class="fc" id="L183">		}</span>

<span class="fc" id="L185">		final ConstantExpression expression =</span>
<span class="fc" id="L186">			ConstantExpression.forValue((double) sumOverAllMeasurementResultValues / numberOfAllMeasurementResults);</span>
<span class="fc" id="L187">		blackboard.addProposedExpressionFor(rdia, expression);</span>
<span class="fc" id="L188">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, rdia);</span>
<span class="fc" id="L189">	}</span>

	/**
	 * Note: Not yet implemented. This method creates an averaging
	 * {@link EvaluableExpression} over all given measurement results for this
	 * {@link MeasurableSeffElement} and adds it to the given {@link Blackboard}. At the
	 * end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param seffBranch MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final SeffBranch seffBranch) {

		// final Set&lt;BranchDecisionMeasurementResult&gt; measurementResults =
		// blackboard.getMeasurementResultsFor(seffBranch);
		// final int numberOfBranchDecisions[] = new int[seffBranch.getBranches().size()];
		// final int numberOfAllMeasurementResults = measurementResults.size();

		// for (BranchDecisionMeasurementResult bdmr : measurementResults) {
		// numberOfBranchDecisions[bdmr.getBranchIndex()]++;
		// }

		// HERE SHOULD THE EVALUABLEEXPRESSION FOR BRANCHES BE CREATED AND ADDED TO THE
		// BLACKBOARD

<span class="fc" id="L219">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, seffBranch);</span>
<span class="fc" id="L220">	}</span>

	/**
	 * This method creates an averaging {@link EvaluableExpression} over all given
	 * measurement results for this {@link MeasurableSeffElement} and adds it to the given
	 * {@link Blackboard}. At the end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param seffLoop MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final SeffLoop seffLoop) {

<span class="fc" id="L237">		final Set&lt;LoopRepetitionCountMeasurementResult&gt; loopCountResults =</span>
<span class="fc" id="L238">			blackboard.getMeasurementResultsFor(seffLoop);</span>
<span class="fc" id="L239">		int sumOverAllLoopCounts = 0;</span>
<span class="fc" id="L240">		final int numberOfAllMeasurementResults = loopCountResults.size();</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">		for (final LoopRepetitionCountMeasurementResult loopCountResult : loopCountResults) {</span>
<span class="fc" id="L243">			sumOverAllLoopCounts += loopCountResult.getCount();</span>
<span class="fc" id="L244">		}</span>

<span class="fc" id="L246">		final ConstantExpression expression =</span>
<span class="fc" id="L247">			ConstantExpression.forValue((double) sumOverAllLoopCounts / numberOfAllMeasurementResults);</span>
<span class="fc" id="L248">		blackboard.addProposedExpressionFor(seffLoop, expression);</span>
<span class="fc" id="L249">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, seffLoop);</span>
<span class="fc" id="L250">	}</span>

	/**
	 * Note: Not yet implemented. This method creates an averaging This method creates an
	 * averaging {@link EvaluableExpression} over all given measurement results for this
	 * {@link MeasurableSeffElement} and adds it to the given {@link Blackboard}. At the
	 * end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param exParam MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final ExternalCallParameter exParam) {

<span class="fc" id="L268">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, exParam);</span>
<span class="fc" id="L269">	}</span>

	/**
	 * This method is very important to be called right after this Analyser-class has
	 * contributed. It makes the annotation on its blackboard stored HashMap, that he
	 * contributed for a {@link MeasurableSeffElement} with a specific number of
	 * MeasurementResults that have flown into its ProposedExpression.
	 *
	 * @param blackboard To read and write from
	 * @param measurableSeffElement MeasurableSeff for which a ProposedExpression has been
	 *            added
	 */
	private void mapCurrentNumberOfMeasurementResultsToSeffElement(
		final MeasurementResultAnalyserBlackboardView blackboard, final MeasurableSeffElement measurableSeffElement) {

<span class="fc" id="L284">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="fc" id="L285">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>
<span class="fc" id="L286">		measurableSeffContributions.put(measurableSeffElement,</span>
<span class="fc" id="L287">			new Integer(this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement)));</span>
<span class="fc" id="L288">	}</span>

	/**
	 * Returning the number of MeasurementResults for a given
	 * {@link MeasurableSeffElement}.
	 *
	 * @param blackboard the blackboard to read from
	 * @param measurableSeffElement Checking the MeasruementResults for this blackboard
	 *            contained element
	 * @return number of MeasurementResults
	 */
	private int numberOfMeasurementResultsForSeffElement(
		final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard,
		final MeasurableSeffElement measurableSeffElement) {
<span class="fc" id="L302">		int numberOfMeasurements = 0;</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">		if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="fc" id="L305">			numberOfMeasurements =</span>
<span class="fc" id="L306">				blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L308">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="fc" id="L310">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L312">			numberOfMeasurements =</span>
<span class="nc" id="L313">				blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
		}

<span class="fc" id="L316">		return numberOfMeasurements;</span>
	}

	/**
	 * Returning the number of MeasurementResults for a given
	 * {@link MeasurableSeffElement}.
	 *
	 * @param blackboard the blackboard to read from
	 * @param measurableSeffElement Checking the MeasruementResults for this blackboard
	 *            contained element
	 * @return number of MeasurementResults
	 */
	private int numberOfMeasurementResultsForSeffElement(final MeasurementResultAnalyserBlackboardView blackboard,
		final MeasurableSeffElement measurableSeffElement) {
<span class="fc" id="L330">		int numberOfMeasurements = 0;</span>

<span class="fc bfc" id="L332" title="All 2 branches covered.">		if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="fc" id="L333">			numberOfMeasurements =</span>
<span class="fc" id="L334">				blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">		} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="fc" id="L336">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">		} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="fc" id="L338">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">		} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="fc" id="L340">			numberOfMeasurements =</span>
<span class="fc" id="L341">				blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
		}

<span class="fc" id="L344">		return numberOfMeasurements;</span>
	}

	/**
	 * This will create a {@link HashMap}, mapping all {@link MeasurableSeffElement} to
	 * the Integer value 0.
	 *
	 * @param blackboard The {@link Blackboard} to get the SeffElements from.
	 * @return A Map of all blackboard contained SeffElements to Integer value 0.
	 */
	private HashMap&lt;MeasurableSeffElement, Integer&gt; initializeMap(
		final MeasurementResultAnalyserBlackboardView blackboard) {
<span class="fc" id="L356">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
			new HashMap&lt;MeasurableSeffElement, Integer&gt;();
<span class="fc" id="L358">		final Set&lt;MeasurableSeffElement&gt; allMeasurableSeffElementsOnBlackboard = new HashSet&lt;MeasurableSeffElement&gt;();</span>

<span class="fc bfc" id="L360" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllRdias()) {</span>
<span class="fc" id="L361">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L362">		}</span>

<span class="fc bfc" id="L364" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffBranches()) {</span>
<span class="fc" id="L365">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L366">		}</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffLoops()) {</span>
<span class="fc" id="L369">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L370">		}</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : blackboard.getAllExternalCallParameters()) {</span>
<span class="fc" id="L373">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="fc" id="L374">		}</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">		for (final MeasurableSeffElement measurableSeffElement : allMeasurableSeffElementsOnBlackboard) {</span>
<span class="fc" id="L377">			measurableSeffContributions.put(measurableSeffElement, new Integer(0));</span>
<span class="fc" id="L378">		}</span>

<span class="fc" id="L380">		return measurableSeffContributions;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>