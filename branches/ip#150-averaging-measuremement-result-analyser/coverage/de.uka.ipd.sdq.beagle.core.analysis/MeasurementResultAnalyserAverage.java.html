<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MeasurementResultAnalyserAverage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core</a> &gt; <a href="index.source.html" class="el_package">de.uka.ipd.sdq.beagle.core.analysis</a> &gt; <span class="el_source">MeasurementResultAnalyserAverage.java</span></div><h1>MeasurementResultAnalyserAverage.java</h1><pre class="source lang-java linenums">package de.uka.ipd.sdq.beagle.core.analysis;

import de.uka.ipd.sdq.beagle.core.Blackboard;
import de.uka.ipd.sdq.beagle.core.BlackboardStorer;
import de.uka.ipd.sdq.beagle.core.ExternalCallParameter;
import de.uka.ipd.sdq.beagle.core.MeasurableSeffElement;
import de.uka.ipd.sdq.beagle.core.ResourceDemandingInternalAction;
import de.uka.ipd.sdq.beagle.core.SeffBranch;
import de.uka.ipd.sdq.beagle.core.SeffLoop;
import de.uka.ipd.sdq.beagle.core.evaluableexpressions.ConstantExpression;
import de.uka.ipd.sdq.beagle.core.evaluableexpressions.EvaluableExpression;
import de.uka.ipd.sdq.beagle.core.measurement.LoopRepetitionCountMeasurementResult;
import de.uka.ipd.sdq.beagle.core.measurement.ResourceDemandMeasurementResult;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * This implementation of {@link MeasurementResultAnalyser} will contribute with static
 * created ProposedExpressions. It will take all SeffElements and use respectively
 * all their MeasurementResults on the {@link Blackboard} and calculate thereby an
 * expression that fits best to the average expectancy value. Its implementation of
 * {@link #canContribute(ReadOnlyMeasurementResultAnalyserBlackboardView)} checks if there
 * are any MeasurementResults for a SeffElement, that have not been flown into the average
 * proposed Expression so far.
 * 
 * 
 * @author Ansgar Spiegler
 */
<span class="nc" id="L31">public class MeasurementResultAnalyserAverage</span>
	implements MeasurementResultAnalyser, BlackboardStorer&lt;HashMap&lt;MeasurableSeffElement, Integer&gt;&gt; {

	@Override
	public boolean canContribute(final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard) {

<span class="nc" id="L37">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="nc" id="L38">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="nc bnc" id="L40" title="All 2 branches missed.">		if (measurableSeffContributions == null) {</span>
<span class="nc" id="L41">			return true;</span>
		}

<span class="nc bnc" id="L44" title="All 2 branches missed.">		if (measurableSeffContributions.isEmpty()) {</span>
<span class="nc" id="L45">			return false;</span>
		}

<span class="nc bnc" id="L48" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : measurableSeffContributions.keySet()) {</span>

<span class="nc" id="L50">			final Integer numberOfMeasurements =</span>
<span class="nc" id="L51">				this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement);</span>

<span class="nc bnc" id="L53" title="All 2 branches missed.">			if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L54">				return true;</span>
			}
<span class="nc" id="L56">		}</span>

<span class="nc" id="L58">		return false;</span>
	}

	@Override
	public void contribute(final MeasurementResultAnalyserBlackboardView blackboard) {

<span class="nc" id="L64">		final HashMap&lt;MeasurableSeffElement, Integer&gt; writtenContent =</span>
<span class="nc" id="L65">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="nc bnc" id="L67" title="All 2 branches missed.">		if (writtenContent == null) {</span>
<span class="nc" id="L68">			final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions = this.initializeMap(blackboard);</span>
<span class="nc" id="L69">			blackboard.writeFor(MeasurementResultAnalyserAverage.class, measurableSeffContributions);</span>
		}

<span class="nc" id="L72">		this.scanAllMeasurableSeffElements(blackboard);</span>

<span class="nc" id="L74">	}</span>

	/**
	 * Scanning all {@link MeasurableSeffElement} for given MeasurementResults. If there
	 * are more results than the number of results for a previous propose have been used,
	 * a new ProposedExpression is added by
	 * {@link #addMeasurementResultFor(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 *
	 * @param blackboard the {@link Blackboard} to read and write from
	 */
	private void scanAllMeasurableSeffElements(final MeasurementResultAnalyserBlackboardView blackboard) {

<span class="nc" id="L86">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="nc" id="L87">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="nc bnc" id="L89" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : measurableSeffContributions.keySet()) {</span>

			Integer numberOfMeasurements;

<span class="nc bnc" id="L93" title="All 2 branches missed.">			if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="nc" id="L94">				numberOfMeasurements =</span>
<span class="nc" id="L95">					blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L97">					this.addMeasurementResultFor(blackboard, (ResourceDemandingInternalAction) measurableSeffElement);</span>
				}
<span class="nc bnc" id="L99" title="All 2 branches missed.">			} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L100">				numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L102">					this.addMeasurementResultFor(blackboard, (SeffBranch) measurableSeffElement);</span>
				}
<span class="nc bnc" id="L104" title="All 2 branches missed.">			} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="nc" id="L105">				numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L107">					this.addMeasurementResultFor(blackboard, (SeffLoop) measurableSeffElement);</span>
				}
<span class="nc bnc" id="L109" title="All 2 branches missed.">			} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L110">				numberOfMeasurements =</span>
<span class="nc" id="L111">					blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L113">					this.addMeasurementResultFor(blackboard, (ExternalCallParameter) measurableSeffElement);</span>
				}
			}

<span class="nc" id="L117">		}</span>

<span class="nc" id="L119">	}</span>

	/**
	 * This method creates an averaging {@link EvaluableExpression} over all given
	 * measurement results for this {@link MeasurableSeffElement} and adds it to the given
	 * {@link Blackboard}. At the end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param rdia MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final ResourceDemandingInternalAction rdia) {

<span class="nc" id="L136">		final Set&lt;ResourceDemandMeasurementResult&gt; measurementResults = blackboard.getMeasurementResultsFor(rdia);</span>
<span class="nc" id="L137">		int sumOverAllMeasurementResultValues = 0;</span>
<span class="nc" id="L138">		final int numberOfAllMeasurementResults = measurementResults.size();</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">		for (ResourceDemandMeasurementResult rdmr : measurementResults) {</span>
<span class="nc" id="L141">			sumOverAllMeasurementResultValues += rdmr.getValue();</span>
<span class="nc" id="L142">		}</span>

<span class="nc" id="L144">		final ConstantExpression expression =</span>
<span class="nc" id="L145">			ConstantExpression.forValue((double) sumOverAllMeasurementResultValues / numberOfAllMeasurementResults);</span>
<span class="nc" id="L146">		blackboard.addProposedExpressionFor(rdia, expression);</span>
<span class="nc" id="L147">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, rdia);</span>
<span class="nc" id="L148">	}</span>

	/**
	 * Note: Not yet implemented. This method creates an averaging
	 * {@link EvaluableExpression} over all given measurement results for this
	 * {@link MeasurableSeffElement} and adds it to the given {@link Blackboard}. At the
	 * end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param seffBranch MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final SeffBranch seffBranch) {

		// final Set&lt;BranchDecisionMeasurementResult&gt; measurementResults =
		// blackboard.getMeasurementResultsFor(seffBranch);
		// final int numberOfBranchDecisions[] = new int[seffBranch.getBranches().size()];
		// final int numberOfAllMeasurementResults = measurementResults.size();

		// for (BranchDecisionMeasurementResult bdmr : measurementResults) {
		// numberOfBranchDecisions[bdmr.getBranchIndex()]++;
		// }

		// HERE SHOULD THE EVALUABLEEXPRESSION FOR BRANCHES BE CREATED AND ADDED TO THE
		// BLACKBOARD

<span class="nc" id="L178">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, seffBranch);</span>
<span class="nc" id="L179">	}</span>

	/**
	 * This method creates an averaging {@link EvaluableExpression} over all given
	 * measurement results for this {@link MeasurableSeffElement} and adds it to the given
	 * {@link Blackboard}. At the end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param seffLoop MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final SeffLoop seffLoop) {

<span class="nc" id="L196">		final Set&lt;LoopRepetitionCountMeasurementResult&gt; loopCountResults =</span>
<span class="nc" id="L197">			blackboard.getMeasurementResultsFor(seffLoop);</span>
<span class="nc" id="L198">		int sumOverAllLoopCounts = 0;</span>
<span class="nc" id="L199">		final int numberOfAllMeasurementResults = loopCountResults.size();</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">		for (LoopRepetitionCountMeasurementResult loopCountResult : loopCountResults) {</span>
<span class="nc" id="L202">			sumOverAllLoopCounts += loopCountResult.getCount();</span>
<span class="nc" id="L203">		}</span>

<span class="nc" id="L205">		final ConstantExpression expression =</span>
<span class="nc" id="L206">			ConstantExpression.forValue((double) sumOverAllLoopCounts / numberOfAllMeasurementResults);</span>
<span class="nc" id="L207">		blackboard.addProposedExpressionFor(seffLoop, expression);</span>
<span class="nc" id="L208">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, seffLoop);</span>
<span class="nc" id="L209">	}</span>

	/**
	 * Note: Not yet implemented. This method creates an averaging This method creates an
	 * averaging {@link EvaluableExpression} over all given measurement results for this
	 * {@link MeasurableSeffElement} and adds it to the given {@link Blackboard}. At the
	 * end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param exParam MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final ExternalCallParameter exParam) {

<span class="nc" id="L227">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, exParam);</span>
<span class="nc" id="L228">	}</span>

	/**
	 * This method is very important to be called right after this Analyser-class has
	 * contributed. It makes the annotation on its blackboard stored HashMap, that he
	 * contributed for a {@link MeasurableSeffElement} with a specific number of
	 * MeasurementResults that have flown into its ProposedExpression.
	 *
	 * @param blackboard To read and write from
	 * @param measurableSeffElement MeasurableSeff for which a ProposedExpression has been
	 *            added
	 */
	private void mapCurrentNumberOfMeasurementResultsToSeffElement(
		final MeasurementResultAnalyserBlackboardView blackboard, final MeasurableSeffElement measurableSeffElement) {

<span class="nc" id="L243">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="nc" id="L244">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>
<span class="nc" id="L245">		measurableSeffContributions.put(measurableSeffElement,</span>
<span class="nc" id="L246">			new Integer(this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement)));</span>
<span class="nc" id="L247">	}</span>

	/**
	 * Returning the number of MeasurementResults for a given
	 * {@link MeasurableSeffElement}.
	 *
	 * @param blackboard the blackboard to read from
	 * @param measurableSeffElement Checking the MeasruementResults for this blackboard
	 *            contained element
	 * @return number of MeasurementResults
	 */
	private int numberOfMeasurementResultsForSeffElement(
		final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard,
		final MeasurableSeffElement measurableSeffElement) {
<span class="nc" id="L261">		int numberOfMeasurements = 0;</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">		if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="nc" id="L264">			numberOfMeasurements =</span>
<span class="nc" id="L265">				blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L267">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="nc" id="L269">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L271">			numberOfMeasurements =</span>
<span class="nc" id="L272">				blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
		}

<span class="nc" id="L275">		return numberOfMeasurements;</span>
	}

	/**
	 * Returning the number of MeasurementResults for a given
	 * {@link MeasurableSeffElement}.
	 *
	 * @param blackboard the blackboard to read from
	 * @param measurableSeffElement Checking the MeasruementResults for this blackboard
	 *            contained element
	 * @return number of MeasurementResults
	 */
	private int numberOfMeasurementResultsForSeffElement(final MeasurementResultAnalyserBlackboardView blackboard,
		final MeasurableSeffElement measurableSeffElement) {
<span class="nc" id="L289">		int numberOfMeasurements = 0;</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="nc" id="L292">			numberOfMeasurements =</span>
<span class="nc" id="L293">				blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L295">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="nc" id="L297">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L299">			numberOfMeasurements =</span>
<span class="nc" id="L300">				blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
		}

<span class="nc" id="L303">		return numberOfMeasurements;</span>
	}

	/**
	 * This will create a {@link HashMap}, mapping all {@link MeasurableSeffElement} to
	 * the Integer value 0.
	 *
	 * @param blackboard The {@link Blackboard} to get the SeffElements from.
	 * @return A Map of all blackboard contained SeffElements to Integer value 0.
	 */
	private HashMap&lt;MeasurableSeffElement, Integer&gt; initializeMap(
		final MeasurementResultAnalyserBlackboardView blackboard) {
<span class="nc" id="L315">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
			new HashMap&lt;MeasurableSeffElement, Integer&gt;();
<span class="nc" id="L317">		final Set&lt;MeasurableSeffElement&gt; allMeasurableSeffElementsOnBlackboard = new HashSet&lt;MeasurableSeffElement&gt;();</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllRdias()) {</span>
<span class="nc" id="L320">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L321">		}</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffBranches()) {</span>
<span class="nc" id="L324">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L325">		}</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffLoops()) {</span>
<span class="nc" id="L328">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L329">		}</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllExternalCallParameters()) {</span>
<span class="nc" id="L332">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L333">		}</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : allMeasurableSeffElementsOnBlackboard) {</span>
<span class="nc" id="L336">			measurableSeffContributions.put(measurableSeffElement, new Integer(0));</span>
<span class="nc" id="L337">		}</span>

<span class="nc" id="L339">		return measurableSeffContributions;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>