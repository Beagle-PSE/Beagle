<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MeasurementResultAnalyserAverage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core</a> &gt; <a href="index.source.html" class="el_package">de.uka.ipd.sdq.beagle.core.analysis</a> &gt; <span class="el_source">MeasurementResultAnalyserAverage.java</span></div><h1>MeasurementResultAnalyserAverage.java</h1><pre class="source lang-java linenums">package de.uka.ipd.sdq.beagle.core.analysis;

import de.uka.ipd.sdq.beagle.core.Blackboard;
import de.uka.ipd.sdq.beagle.core.BlackboardStorer;
import de.uka.ipd.sdq.beagle.core.ExternalCallParameter;
import de.uka.ipd.sdq.beagle.core.MeasurableSeffElement;
import de.uka.ipd.sdq.beagle.core.ResourceDemandingInternalAction;
import de.uka.ipd.sdq.beagle.core.SeffBranch;
import de.uka.ipd.sdq.beagle.core.SeffLoop;
import de.uka.ipd.sdq.beagle.core.evaluableexpressions.ConstantExpression;
import de.uka.ipd.sdq.beagle.core.evaluableexpressions.EvaluableExpression;
import de.uka.ipd.sdq.beagle.core.measurement.LoopRepetitionCountMeasurementResult;
import de.uka.ipd.sdq.beagle.core.measurement.ResourceDemandMeasurementResult;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * This implementation of {@link MeasurementResultAnalyser} will contribute with static
 * created {@link ProposedExpression}. It will take all SeffElements and use respectively
 * all their MeasurementResults on the {@link Blackboard} and calculate thereby an
 * expression that fits best to the average expectancy value. Its implementation of
 * {@link #canContribute(ReadOnlyMeasurementResultAnalyserBlackboardView)} checks if there
 * are any MeasurementResults for a SeffElement, that have not been flown into the average
 * proposed Expression so far.
 * 
 * 
 * @author Ansgar Spiegler
 */
<span class="nc" id="L31">public class MeasurementResultAnalyserAverage implements MeasurementResultAnalyser, BlackboardStorer&lt;HashMap&lt;MeasurableSeffElement, Integer&gt;&gt; {</span>

	@Override
	public boolean canContribute(final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard) {

<span class="nc" id="L36">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="nc" id="L37">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="nc bnc" id="L39" title="All 2 branches missed.">		if (measurableSeffContributions == null) {</span>
<span class="nc" id="L40">			return true;</span>
		}

<span class="nc bnc" id="L43" title="All 2 branches missed.">		if (measurableSeffContributions.isEmpty()) {</span>
<span class="nc" id="L44">			return false;</span>
		}

<span class="nc bnc" id="L47" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : measurableSeffContributions.keySet()) {</span>

<span class="nc" id="L49">			final Integer numberOfMeasurements =</span>
<span class="nc" id="L50">				this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement);</span>

<span class="nc bnc" id="L52" title="All 2 branches missed.">			if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L53">				return true;</span>
			}
<span class="nc" id="L55">		}</span>

<span class="nc" id="L57">		return false;</span>
	}

	@Override
	public void contribute(final MeasurementResultAnalyserBlackboardView blackboard) {

<span class="nc" id="L63">		final HashMap&lt;MeasurableSeffElement, Integer&gt; writtenContent =</span>
<span class="nc" id="L64">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">		if (writtenContent == null) {</span>
<span class="nc" id="L67">			final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions = this.initializeMap(blackboard);</span>
<span class="nc" id="L68">			blackboard.writeFor(MeasurementResultAnalyserAverage.class, measurableSeffContributions);</span>
		}

<span class="nc" id="L71">		this.scanAllMeasurableSeffElements(blackboard);</span>

<span class="nc" id="L73">	}</span>

	/**
	 * Scanning all {@link MeasurableSeffElement} for given MeasurementResults. If there
	 * are more results than the number of results for a previous propose have been used,
	 * a new ProposedExpression is added by
	 * {@link #addMeasurementResultFor(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)
	 *
	 * @param blackboard the {@link Blackboard} to read and write from
	 */
	private void scanAllMeasurableSeffElements(final MeasurementResultAnalyserBlackboardView blackboard) {

<span class="nc" id="L85">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="nc" id="L86">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>

<span class="nc bnc" id="L88" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : measurableSeffContributions.keySet()) {</span>

			Integer numberOfMeasurements;

<span class="nc bnc" id="L92" title="All 2 branches missed.">			if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="nc" id="L93">				numberOfMeasurements =</span>
<span class="nc" id="L94">					blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L96">					this.addMeasurementResultFor(blackboard, (ResourceDemandingInternalAction) measurableSeffElement);</span>
				}
<span class="nc bnc" id="L98" title="All 2 branches missed.">			} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L99">				numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L101">					this.addMeasurementResultFor(blackboard, (SeffBranch) measurableSeffElement);</span>
				}
<span class="nc bnc" id="L103" title="All 2 branches missed.">			} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="nc" id="L104">				numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L106">					this.addMeasurementResultFor(blackboard, (SeffLoop) measurableSeffElement);</span>
				}
<span class="nc bnc" id="L108" title="All 2 branches missed.">			} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L109">				numberOfMeasurements =</span>
<span class="nc" id="L110">					blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">				if (measurableSeffContributions.get(measurableSeffElement) &lt; numberOfMeasurements) {</span>
<span class="nc" id="L112">					this.addMeasurementResultFor(blackboard, (ExternalCallParameter) measurableSeffElement);</span>
				}
			}

<span class="nc" id="L116">		}</span>

<span class="nc" id="L118">	}</span>

	/**
	 * This method creates an averaging {@link EvaluableExpression} over all given
	 * measurement results for this {@link MeasurableSeffElement} and adds it to the given
	 * {@link Blackboard}. At the end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param rdia MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final ResourceDemandingInternalAction rdia) {

<span class="nc" id="L135">		final Set&lt;ResourceDemandMeasurementResult&gt; measurementResults = blackboard.getMeasurementResultsFor(rdia);</span>
<span class="nc" id="L136">		int sumOverAllMeasurementResultValues = 0;</span>
<span class="nc" id="L137">		final int numberOfAllMeasurementResults = measurementResults.size();</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">		for (ResourceDemandMeasurementResult rdmr : measurementResults) {</span>
<span class="nc" id="L140">			sumOverAllMeasurementResultValues += rdmr.getValue();</span>
<span class="nc" id="L141">		}</span>

<span class="nc" id="L143">		final ConstantExpression expression =</span>
<span class="nc" id="L144">			ConstantExpression.forValue((double) sumOverAllMeasurementResultValues / numberOfAllMeasurementResults);</span>
<span class="nc" id="L145">		blackboard.addProposedExpressionFor(rdia, expression);</span>
<span class="nc" id="L146">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, rdia);</span>
<span class="nc" id="L147">	}</span>

	/**
	 * Note: Not yet implemented. This method creates an averaging
	 * {@link EvaluableExpression} over all given measurement results for this
	 * {@link MeasurableSeffElement} and adds it to the given {@link Blackboard}. At the
	 * end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param seffBranch MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final SeffBranch seffBranch) {

		// final Set&lt;BranchDecisionMeasurementResult&gt; measurementResults =
		// blackboard.getMeasurementResultsFor(seffBranch);
		// final int numberOfBranchDecisions[] = new int[seffBranch.getBranches().size()];
		// final int numberOfAllMeasurementResults = measurementResults.size();

		// for (BranchDecisionMeasurementResult bdmr : measurementResults) {
		// numberOfBranchDecisions[bdmr.getBranchIndex()]++;
		// }

		// HERE SHOULD THE EVALUABLEEXPRESSION FOR BRANCHES BE CREATED AND ADDED TO THE
		// BLACKBOARD

<span class="nc" id="L177">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, seffBranch);</span>
<span class="nc" id="L178">	}</span>

	/**
	 * This method creates an averaging {@link EvaluableExpression} over all given
	 * measurement results for this {@link MeasurableSeffElement} and adds it to the given
	 * {@link Blackboard}. At the end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param seffLoop MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final SeffLoop seffLoop) {

<span class="nc" id="L195">		final Set&lt;LoopRepetitionCountMeasurementResult&gt; loopCountResults =</span>
<span class="nc" id="L196">			blackboard.getMeasurementResultsFor(seffLoop);</span>
<span class="nc" id="L197">		int sumOverAllLoopCounts = 0;</span>
<span class="nc" id="L198">		final int numberOfAllMeasurementResults = loopCountResults.size();</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">		for (LoopRepetitionCountMeasurementResult loopCountResult : loopCountResults) {</span>
<span class="nc" id="L201">			sumOverAllLoopCounts += loopCountResult.getCount();</span>
<span class="nc" id="L202">		}</span>

<span class="nc" id="L204">		final ConstantExpression expression =</span>
<span class="nc" id="L205">			ConstantExpression.forValue((double) sumOverAllLoopCounts / numberOfAllMeasurementResults);</span>
<span class="nc" id="L206">		blackboard.addProposedExpressionFor(seffLoop, expression);</span>
<span class="nc" id="L207">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, seffLoop);</span>
<span class="nc" id="L208">	}</span>

	/**
	 * Note: Not yet implemented. This method creates an averaging This method creates an
	 * averaging {@link EvaluableExpression} over all given measurement results for this
	 * {@link MeasurableSeffElement} and adds it to the given {@link Blackboard}. At the
	 * end, this test MUST Call
	 * {@link #mapCurrentNumberOfMeasurementResultsToSeffElement(MeasurementResultAnalyserBlackboardView, MeasurableSeffElement)}
	 * so that this class knows, that is has contributed. Mistakes may cause an endless
	 * running behavior of Beagle!
	 *
	 * @param blackboard To read and write from
	 * @param exParam MeasurableSeff for which this method should calculate the average
	 *            {@link EvaluableExpression}
	 */
	private void addMeasurementResultFor(final MeasurementResultAnalyserBlackboardView blackboard,
		final ExternalCallParameter exParam) {

<span class="nc" id="L226">		this.mapCurrentNumberOfMeasurementResultsToSeffElement(blackboard, exParam);</span>
<span class="nc" id="L227">	}</span>

	/**
	 * This method is very important to be called right after this Analyser-class has
	 * contributed. It makes the annotation on its blackboard stored HashMap, that he
	 * contributed for a {@link MeasurableSeffElement} with a specific number of
	 * MeasurementResults that have flown into its ProposedExpression.
	 *
	 * @param blackboard To read and write from
	 * @param measurableSeffElement MeasurableSeff for which a ProposedExpression has been
	 *            added
	 */
	private void mapCurrentNumberOfMeasurementResultsToSeffElement(
		final MeasurementResultAnalyserBlackboardView blackboard, final MeasurableSeffElement measurableSeffElement) {

<span class="nc" id="L242">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
<span class="nc" id="L243">			blackboard.readFor(MeasurementResultAnalyserAverage.class);</span>
<span class="nc" id="L244">		measurableSeffContributions.put(measurableSeffElement,</span>
<span class="nc" id="L245">			new Integer(this.numberOfMeasurementResultsForSeffElement(blackboard, measurableSeffElement)));</span>
<span class="nc" id="L246">	}</span>

	/**
	 * Returning the number of MeasurementResults for a given
	 * {@link MeasurableSeffElement}.
	 *
	 * @param blackboard the blackboard to read from
	 * @param measurableSeffElement Checking the MeasruementResults for this blackboard
	 *            contained element
	 * @return number of MeasurementResults
	 */
	private int numberOfMeasurementResultsForSeffElement(
		final ReadOnlyMeasurementResultAnalyserBlackboardView blackboard,
		final MeasurableSeffElement measurableSeffElement) {
<span class="nc" id="L260">		int numberOfMeasurements = 0;</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">		if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="nc" id="L263">			numberOfMeasurements =</span>
<span class="nc" id="L264">				blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L266">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="nc" id="L268">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L270">			numberOfMeasurements =</span>
<span class="nc" id="L271">				blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
		}

<span class="nc" id="L274">		return numberOfMeasurements;</span>
	}

	/**
	 * Returning the number of MeasurementResults for a given
	 * {@link MeasurableSeffElement}.
	 *
	 * @param blackboard the blackboard to read from
	 * @param measurableSeffElement Checking the MeasruementResults for this blackboard
	 *            contained element
	 * @return number of MeasurementResults
	 */
	private int numberOfMeasurementResultsForSeffElement(final MeasurementResultAnalyserBlackboardView blackboard,
		final MeasurableSeffElement measurableSeffElement) {
<span class="nc" id="L288">		int numberOfMeasurements = 0;</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">		if (measurableSeffElement.getClass() == ResourceDemandingInternalAction.class) {</span>
<span class="nc" id="L291">			numberOfMeasurements =</span>
<span class="nc" id="L292">				blackboard.getMeasurementResultsFor((ResourceDemandingInternalAction) measurableSeffElement).size();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffBranch.class) {</span>
<span class="nc" id="L294">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffBranch) measurableSeffElement).size();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == SeffLoop.class) {</span>
<span class="nc" id="L296">			numberOfMeasurements = blackboard.getMeasurementResultsFor((SeffLoop) measurableSeffElement).size();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">		} else if (measurableSeffElement.getClass() == ExternalCallParameter.class) {</span>
<span class="nc" id="L298">			numberOfMeasurements =</span>
<span class="nc" id="L299">				blackboard.getMeasurementResultsFor((ExternalCallParameter) measurableSeffElement).size();</span>
		}

<span class="nc" id="L302">		return numberOfMeasurements;</span>
	}

	/**
	 * This will create a {@link HashMap}, mapping all {@link MeasurableSeffElement} to
	 * the Integer value 0.
	 *
	 * @param blackboard The {@link Blackboard} to get the SeffElements from.
	 * @return A Map of all blackboard contained SeffElements to Integer value 0.
	 */
	private HashMap&lt;MeasurableSeffElement, Integer&gt; initializeMap(
		final MeasurementResultAnalyserBlackboardView blackboard) {
<span class="nc" id="L314">		final HashMap&lt;MeasurableSeffElement, Integer&gt; measurableSeffContributions =</span>
			new HashMap&lt;MeasurableSeffElement, Integer&gt;();
<span class="nc" id="L316">		final Set&lt;MeasurableSeffElement&gt; allMeasurableSeffElementsOnBlackboard = new HashSet&lt;MeasurableSeffElement&gt;();</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllRdias()) {</span>
<span class="nc" id="L319">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L320">		}</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffBranches()) {</span>
<span class="nc" id="L323">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L324">		}</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllSeffLoops()) {</span>
<span class="nc" id="L327">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L328">		}</span>

<span class="nc bnc" id="L330" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : blackboard.getAllExternalCallParameters()) {</span>
<span class="nc" id="L331">			allMeasurableSeffElementsOnBlackboard.add(measurableSeffElement);</span>
<span class="nc" id="L332">		}</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">		for (MeasurableSeffElement measurableSeffElement : allMeasurableSeffElementsOnBlackboard) {</span>
<span class="nc" id="L335">			measurableSeffContributions.put(measurableSeffElement, new Integer(0));</span>
<span class="nc" id="L336">		}</span>

<span class="nc" id="L338">		return measurableSeffContributions;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>