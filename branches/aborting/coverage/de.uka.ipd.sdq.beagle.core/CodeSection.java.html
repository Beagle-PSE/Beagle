<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CodeSection.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core</a> &gt; <a href="index.source.html" class="el_package">de.uka.ipd.sdq.beagle.core</a> &gt; <span class="el_source">CodeSection.java</span></div><h1>CodeSection.java</h1><pre class="source lang-java linenums">package de.uka.ipd.sdq.beagle.core;

import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import java.io.File;
import java.io.Serializable;

/**
 * Describes a section in examined software’s source code. Code sections may span multiple
 * methods, types and compilation units. They are defined by a start statement in one
 * source code file and an end statement in another source code file that may or may not
 * be the same as the first one. A statement is identified by the index of the statement’s
 * first character in its source file. Code sections are immutable, meaning that once
 * created, their attributes cannot be changed.
 *
 * &lt;p&gt;A code section must describe a continuous part of source code, meaning that the last
 * statement in the section will always be executed if the first one was executed, given
 * that no Exceptions occur. Furthermore, if the last statement is not the same as the
 * first one, the last statement may only be executed after the first one was. All
 * statements that may potentially be executed after the first statement but before the
 * last one are considered to be “in” the section. A code section is considered to have
 * been “completely executed” if the section’s first and last statement were executed.
 * This does generally not mean that all statements in the section were executed. Code
 * Sections no fulfilling these requirements must not be created. However, this is not
 * checked at run time, because doing so would solve the halting problem.
 *
 * @author Joshua Gleitze
 * @author Roman Langrehr
 */
public class CodeSection implements Serializable {

	/**
	 * Serialisation version UID, see {@link java.io.Serializable}.
	 */
	private static final long serialVersionUID = -1823330022448293103L;

	/**
	 * The java file which contains the {@link #startStatementNumber} of this code
	 * section.
	 */
	private final File startFile;

	/**
	 * This code section’s first statement’s first character’s index in {@link #startFile}
	 * , starting with {@code 0}.
	 */
	private final int startStatementNumber;

	/**
	 * The java file which contains the {@link #endStatementNumber} of this code section.
	 */
	private final File endFile;

	/**
	 * This code section’s last statement’s first character’s index in {@link #endFile},
	 * starting with {@code 0}.
	 */
	private final int endStatementNumber;

	/**
	 * Creates a code section that spans from the statements starting at
	 * {@code startIndex} in {@code startFile} to the statement starting at
	 * {@code endIndex} in {@code endFile}.
	 *
	 * @param startFile The file containing this section’s first statement. Must not be
	 *            {@code null} and {@link File#isFile() startFile.isFile()} must return
	 *            {@code true}.
	 * @param startIndex The index of this section’s first statement’s first character in
	 *            {@code startFile}. Counting starts at {@code 0}.
	 * @param endFile The file containing this section’s last statement. Must not be
	 *            {@code null} and {@link File#isFile() endFile.isFile()} must return
	 *            {@code true}.
	 * @param endIndex The index of this section’s last statement’s first character in
	 *            {@code endFile}. Counting starts at {@code 0}.
	 * @throws IllegalArgumentException When {@code startFile.isFile()} or
	 *             {@code endFile.isFile()} returned {@code false}.
	 * @throws RuntimeException If {@code startFile} or {@code endFile} cannot be read.
	 */
<span class="fc" id="L81">	public CodeSection(final File startFile, final int startIndex, final File endFile, final int endIndex) {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">		if (!startFile.isFile()) {</span>
<span class="fc" id="L83">			throw new IllegalArgumentException(&quot;The given startFile is not a file.&quot;);</span>
		}
<span class="fc bfc" id="L85" title="All 2 branches covered.">		if (!endFile.isFile()) {</span>
<span class="fc" id="L86">			throw new IllegalArgumentException(&quot;The given endFile is not a file.&quot;);</span>
		}
<span class="fc bfc" id="L88" title="All 2 branches covered.">		Validate.isTrue(startIndex &gt;= 0, &quot;The startIndex must be non-neagtive, but was %d&quot;, startIndex);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">		Validate.isTrue(endIndex &gt;= 0, &quot;The endIndex must be non-neagtive, but was %d&quot;, endIndex);</span>
<span class="fc" id="L90">		final long startFileChars = this.countChars(startFile);</span>
<span class="fc" id="L91">		final long endFileChars = this.countChars(endFile);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">		Validate.isTrue(startIndex &lt; startFileChars,</span>
<span class="fc" id="L93">			&quot;The startIndex was not in the startFile. It was %d, but the file’s size was %d.&quot;, startIndex,</span>
<span class="fc" id="L94">			startFileChars);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		Validate.isTrue(endIndex &lt; startFileChars,</span>
<span class="fc" id="L96">			&quot;The endIndex was not in the endFile. It was %d, but the file’s size was %d.&quot;, endIndex, endFileChars);</span>
<span class="fc" id="L97">		this.startFile = startFile;</span>
<span class="fc" id="L98">		this.startStatementNumber = startIndex;</span>
<span class="fc" id="L99">		this.endFile = endFile;</span>
<span class="fc" id="L100">		this.endStatementNumber = endIndex;</span>
<span class="fc" id="L101">	}</span>

	@Override
	public boolean equals(final Object object) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">		if (object == null) {</span>
<span class="fc" id="L106">			return false;</span>
		}
<span class="fc bfc" id="L108" title="All 2 branches covered.">		if (object == this) {</span>
<span class="fc" id="L109">			return true;</span>
		}
<span class="fc bfc" id="L111" title="All 2 branches covered.">		if (object.getClass() != this.getClass()) {</span>
<span class="fc" id="L112">			return false;</span>
		}
<span class="fc" id="L114">		final CodeSection other = (CodeSection) object;</span>
<span class="fc" id="L115">		return new EqualsBuilder().append(this.startFile, other.startFile)</span>
<span class="fc" id="L116">			.append(this.startStatementNumber, other.startStatementNumber)</span>
<span class="fc" id="L117">			.append(this.endFile, other.endFile)</span>
<span class="fc" id="L118">			.append(this.endStatementNumber, other.endStatementNumber)</span>
<span class="fc" id="L119">			.isEquals();</span>
	}

	/**
	 * Gets the file that contains this section’s last statement.
	 *
	 * @return The file containing this section’s last statement. Will never be
	 *         {@code null} and {@code getEndFile().isFile()} always returns {@code true}.
	 */
	public File getEndFile() {
<span class="fc" id="L129">		return this.endFile;</span>
	}

	/**
	 * Gets the index of the first character of the last statement in this code section.
	 * Counting starts at 0. The number thus describes how many characters precede the
	 * section’s last statement in the {@linkplain #getEndFile() end source code file}.
	 *
	 * @return The last statement’s index. A non-negative integer.
	 */
	public int getEndSectionIndex() {
<span class="fc" id="L140">		return this.endStatementNumber;</span>
	}

	/**
	 * Gets the file that contains this section’s first statement.
	 *
	 * @return The file containing this section’s first statement. Will never be
	 *         {@code null} and {@code getStartFile().isFile()} always returns
	 *         {@code true}.
	 */
	public File getStartFile() {
<span class="fc" id="L151">		return this.startFile;</span>
	}

	/**
	 * Gets the index of the first character of the last statement in this code section.
	 * Counting starts at 0. The number thus describes how many characters precede the
	 * section’s last statement in the {@linkplain #getEndFile() end source code file}.
	 *
	 * @return The first statement’s index. A non-negative integer.
	 */
	public int getStartSectionIndex() {
<span class="fc" id="L162">		return this.startStatementNumber;</span>
	}

	@Override
	public int hashCode() {
		// you pick a hard-coded, randomly chosen, non-zero, odd number
		// ideally different for each class
<span class="fc" id="L169">		return new HashCodeBuilder(23, 45).append(this.startFile)</span>
<span class="fc" id="L170">			.append(this.startStatementNumber)</span>
<span class="fc" id="L171">			.append(this.endFile)</span>
<span class="fc" id="L172">			.append(this.endStatementNumber)</span>
<span class="fc" id="L173">			.toHashCode();</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L178">		final String startFileName = this.startFile.getName().replace(&quot;.java&quot;, &quot;&quot;);</span>
<span class="fc" id="L179">		final String endFileName =</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">			this.startFile.equals(this.endFile) ? &quot;&quot; : this.endFile.getName().replace(&quot;.java&quot;, &quot;&quot;) + &quot;:&quot;;</span>
<span class="fc" id="L181">		return String.format(&quot;%s:%d–%s%d&quot;, startFileName, this.startStatementNumber, endFileName,</span>
<span class="fc" id="L182">			this.endStatementNumber);</span>
	}

	/**
	 * Reads the number of characters in a text-file.
	 *
	 * @param file The file to read.
	 * @return The number of bytes in this file. The number of bytes is returned as this
	 *         is, for most source code files, a good approximation for the number of
	 *         characters and the files don't need to be read for this. This approximation
	 *         never produces false errors.
	 */
	private long countChars(final File file) {
<span class="fc" id="L195">		return file.length();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>